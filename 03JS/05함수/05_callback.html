<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>






</head>



<body>



    <script>
        // 콜백함수 ( CALL BACK )
        // 함수를 호출하는 시점이 바뀌어진 형태의 함수
        
        // 기존방식 : 사용자(개발자)가 함수를 직접정의 ->정의된 함수를 호출(call)하여 결과를 반환 받는 방식
        
        // callback : 콜백함수에 인자로 로직이 담긴 함수를(함수주소) 전달하여
        // 콜백함수로부터 처리된 결과를 반환받는 방식
//  ====================================================================================

// 일반 함수 (기존 방식)
// function func(n1,n2){ //평범하게 함수 선언 파라미터 2개
//     console.log("func(n1,n2)...call!"); //함수는 호출되면 기능에 자동으로 "func(n1,n2)...call!"문자열을 출력함
//     return n1+n2 //n1+n2의 값을 반환
// }               // 함수 닫힘
//         const v1 = func(10,20); // call-by-value // 값(value)전달을 통한 함수 직접 실행 (call)
//         console.log(v1);
//         // 결과값
//         // 30


//         //  ====================================================================================
//     // 콜백 함수
//     function callBackFunc(n1,n2,logic){ // 파라미터3개인 함수 정의  
//                                         // 로직에 func를 넣어주면 func의 메모리 주소가 전달
//         console.log('callBackFunc...start...');
//         const v = logic(n1,n2);         // call을 함수 내부에서 직접 함 
//                                         // 로직이 func를 받아와서 이 자리에서 리턴함 즉 cont v = 30; 
//         console.log("v",v);             // v 출력 그러면 30이 나와야 되느 ㄴ거 아니야?
//         console.log('collBackFunc...end...');
//     }
//     callBackFunc(100,200,func);
//     console.log("----------------------------------------------------------------");
//     callBackFunc(100,200,(a,b)=>{return a*b}); 
//     //데이터는 항상 선저장 후처리 즉 이름없는 함수가 만들어졌으면 임의의 메모리 공간에 몰래 저장돼있음
//     console.log("----------------------------------------------------------------");
//     callBackFunc(100,200,()=>{return 111;}); 
//     callBackFunc(100,200,(...args)=>{return 111;});
//     // 콜백함수 내부에서 로직은 2개의 파라미터를 받기로 했지만 건네주지 않거나 가변인자를 사용해도 오류나지 않음 




//  ====================================================================================

        // CallBack 함수로 Map 만들기
        const arr = [
            {id:"111","name":"김홍섭1",age:25,"addr":"대구"},
            {id:"222","name":"기몽섭2",age:18,"addr":"인천"},
            {id:"333","name":"김뭉섭3",age:52,"addr":"부산"},
            {id:"444","name":"김섭4",age:36,"addr":"울산"},
            {id:"555","name":"홍섭5",age:57,"addr":"창원"}
        ]

        function customMap(array,func){ //배열을 받고 로직을 받을 파라미터 2개
            
            // array == arr
            // func == (item)=>{return {"id":item.id,"name":item.name}}
            let newArray = []
            for(let i=0;i<array.length;i++){ //i == 인덱스 번호 0,1,2,3
                const item = array[i]; //0번째 인덱스 {요소}, 1번 인덱스 {요소}, 2번 인덱스 {요소}
                const newitem = func(item);
                newArray.push(newitem);
            }



            return newArray
        }
        // customMap(arr(저장된 배열),()=>{}(처리할 로직));
        // customMap(arr,(item)=>{return {"id":item.id,"name":item.name}   });0
        const arr02 = customMap(arr, (item)=>{return {"id":item.id,"name":item.name}    });
        console.log(arr02);


        // =============================================================================
        // 콜백함수 + 클로저


        function customMap2(array){
            let newArray = [] //state

            // inner Function
            function map(func){

                for(let i=0;i<array.length;i++){
                    const item = array[i];
                    const newitem = func(item);
                    newArray.push(newitem);
                }
                return newArray
            }
            return {"map":map};
        }
        const arr03 =
        customMap2(arr).map((item)=>{return {"id":item.id,"age":item.age} });
        
        console.log(arr03);

        // 예???
    </script>


</body>
</html>