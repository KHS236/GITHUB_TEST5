<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>



</head>
<body>










    <script>

        // // -----------------------------------------------------------------------------
        // // 배열이란 ? : 여러 자료 Type을 저장하기 위한 자료구조
        // // 배열은 순서번호(Index)를 가지고 있고 번호를 통해서 요소값에 접근가능
        // let arr = ['st1',"str2",'str3',null,true,false,undefined,{name:'홍길동',age:15}];
        // console.log(arr);
        // console.log(typeof arr[0]);
        // console.log(typeof arr[1]);
        // console.log(typeof arr[2]);
        // console.log(typeof arr[3]);
        // console.log(typeof arr[4]);
        // console.log(typeof arr[5]);
        // console.log(typeof arr[6]);
        // console.log(typeof arr[7]);
        // // java의 배열과 차이점 = java는 동일한 자료형만 넣을 수 있지만 js에서는 다른 자료형도 한 배열 안에 넣을 수 있따.

        // // -----------------------------------------------------------------------------------------------
        // // js 배열의 공간은 값이 있는 만큼 늘어날 수 있다. (동적확장이 가능하다)
        // arr[8] = 100;
        // console.log(arr[8]);

        // // 9번 인덱스가 없는데 10번 인덱스가 값이 들어감; lenth : 11
        // arr[10] = "HELLO WORLD";
        // console.log(arr[9]); //undefined
        // console.log(arr[10]); //HELLO WORLD
        
        // // 9번 undefined 10번 string 타입
        // console.log(typeof arr[9], typeof arr[10]);

        // // ========================================================
        // // 배열함수 : push , pop (FILO , LIFO)
        // // ========================================================
        // // push == 마지막 인덱스에 데이터를 넣어주는 작업
        // arr.push('aaa');
        // arr.push('bbb');
        // arr.push('ccc');
        // console.log(arr);
        // // 각각 arr의 11, 12 13번째 인덱스에 들어간다.
        
        // // pop == 마지막 요소를 pop하고 뱉어낸다 
        // arr.pop();
        // arr.pop();
        // console.log(arr);
        // // =========================================================
        // // 배열함수 : forEach (많이 사용할 배열 함수)
        // // 배열의 모든 요소를 순차적으로 접근하는 반복구문
        // // 콜백함수 (로직을 전달, 화살표함수)
        // // =========================================================
        // // ()=>{} 앞에 있는 괄호가 각각의 요소를 담는다(item)
        // arr.forEach((item)=>{ console.log('item',item)});
        // // arr.forEach((요소명)=>{} console.log('item',item));
        // // 반복문 대신 쓸 수 이씀


// ============================================================================================

        // // ------------------------------------------------------------
        // // 정렬 : "기존 배열"에서 정렬 (새로운 배열 만들지 않았음)
        // 오름차순:  arr.sort((a,b)=>{return a-b})
        // 내림차순:  arr.sort((a,b)=>{return b-a})
        // // ------------------------------------------------------------
        // let arr2 = [10,55,11,24,5,44,1,22]

        // // 오름차순 정렬
        // //arr.sort();    //[1,10,11,22,24,44,5얘는 왜 여깄음??,55] << 유니코드 어쩌구 문자열 어쩌구..
        // // arr2.sort((a,b)=>{return a-b}); //오름차순 정렬 컴패어 펑션 어쩌구..
        // // console.log(arr2);


        // // //내림차순 정렬
        // // arr2.sort((a,b)=>{return b-a});
        // // console.log(arr2); //[55,44,24,22,11,10,5,1] 정렬됨.
        
        // // 약식
        // arr2.sort((a,b)=>b-a); // 중괄호 리턴 예약어 축약 가능
        // console.log(arr2);


        // // ------------------------------------------------------------
        // // 필터 : 배열 내에서 특정 조건을 만족하는 요소만 걸러온다
        // // arr.filter((요소명)=>{return 조건식})
        // // 필터링 된 결과값은 "새로운 배열"에 담아 만든다.
        // // ------------------------------------------------------------

        // let arr3 = [11,'st1',22,"str2",33,'str3',10.5,null,true,false,undefined,101,{name:'홍길동',age:15}];
        // let result = arr3.filter((item)=>{return typeof item == "number"}) // 왜 여기에 Number가 아니라 문자열 "number"가 들어가요 ??
        // console.log(result);
        // let result2 = arr3.filter((item)=>{return typeof item == "string"})
        // console.log(result2);



        // // ---------------------------------------------------------------
        // // 누산 : arr.reduce(()=>{},누산변수 초기값) << 얘도 많이 씀
        // //                  누적할 때 누적될 시작값 선택하는 거
        // // ---------------------------------------------------------------

        // const sum = arr3.filter((item)=>{return typeof item == "number"})           //숫자값만 필터하고 시작
        //                 .reduce((sum,item)=>{return sum+item;},0)                   //누적합 구하기

        // // 왜 이렇게 해야 돼요 ? 라는 질문을 하려면 만든 사람한테 물어봐야 한다. 그냥 하라는대로 하자
        // console.log(sum); //177.5




//=======================================================================================================



        //----------------------------------
        // 배열 object 처리 [{},{},{},{}...]
        //----------------------------------
        // let arr_5 = [
        //     {pid:"1",pname:"모니터",price:100,amount:50},
        //     {pid:"2",pname:"노트북",price:200,amount:15},
        //     {pid:"3",pname:"냉장고",price:250,amount:30},
        //     {pid:"4",pname:"데스크탑",price:70,amount:19},
        //     {pid:"5",pname:"가습기",price:10,amount:200},
        // ];

        // // console.log(arr_5);
        // // arr_5.forEach((item)=>{console.log(item);});                                         
        // // arr_5.forEach(item=>console.log(item)); //인자가 하나일 경우 소괄호도 생략 가능
        // // arr_5.forEach((item,index)=>{console.log(index,item);})
        // // arr_5.forEach((item,index)=>{console.log(item["price"]);})
                     
        // // 각 item의 가격이 100 이상인 obj만 필터링
        // // const filter_01 = arr_5.filter(item=>item[price] >= 100)                         
        // const filter_01 = arr_5.filter(item=>item.price >= 100)                         
        // console.log(filter_01);




        // // ---------------------문제---------------------------------------------------------
        // // 각 아이템 수량이 30개 이하인 obj만 필터링
        // // const filter_02=
        // // 각 아이템의 가격이 100만원 이상인 item의 가격 총합
        // // const sum =

        // const filter_02 = arr_5.filter(item=>item.amount <=30)
        // console.log(filter_02);
        
        // const sum = arr_5.filter(item=>item.price >=100)  //가격 100 이상인 것만 필터링
        //             .reduce((sum,item)=>{return sum+(item.price*item.amount);},0) // item을 하나씩 순회하면서 sum에 누적
        // console.log(sum);





        // --------------------------------------------------------------------------------------
        // 재구성 배열.map((요소명)=>{재구성할 요소의 형태 return})  <<"리액트에서 밥 먹듯이 씁니다"
        // Array 인스턴스의 map() 메서드는
        // 호출한 배열의 모든 요소에 주어진 함수를 호출한 결과로 채운 "새로운 배열"을 생성
        // --------------------------------------------------------------------------------------
        
        // let arr_6 = [
        //     {pid:"1",pname:"모니터",price:100,amount:50},
        //     {pid:"2",pname:"노트북",price:200,amount:15},
        //     {pid:"3",pname:"냉장고",price:250,amount:30},
        //     {pid:"4",pname:"데스크탑",price:70,amount:19},
        //     {pid:"5",pname:"가습기",price:10,amount:200},
        // ];

        // // let maped_01 = arr_6.map((item)=>{return item;}) // << 기존과 동일한 배열로 재구성 된 것
        // // 새로운 total_price key값 만들기
        // let maped_01 = arr_6.map((item)=>{
        //     item = {...item,"total_price":item.price*item.amount};
        //     // 스프래드 연산자 : ... ( 아이템의 기존 요소 요소를 다시 가져와 담을 때 사용 )
        //     // 추가 속성의 키와 밸류값 추가
        //     console.log("!",item); //각각 순회하는 아이템 하나씩 출력
        //     return item;})
        // console.log(maped_01);





        // ===========================문제2=====================================================
            // 수량이 30이상인 요소만 필터링해서 price가 낮은값 우선 오름차순 / price*amount항목 추가



        // const filter_03 = arr_6.filter((item)=>{return item.amount >=30}) //수량 30이상인 것 필터링
        // console.log('수량이 30개 이상인 요소 ' ,filter_03); //결과 확인

        // let sorted_01 = filter_03.sort((a,b)=>{return a.price - b.price}); // filter_03을 가격 기준 오름차순 정렬 ??
        // console.log('price 오름차순 정렬 ' , sorted_01) //결과 확인

        // let maped_02 = sorted_01.map((item)=>{
        //     item = {...item,"total_price":item.price*item.amount};  //map을 이용해서 sorted_01 요소에 total_price 속성 추가
        // return item;})
        // console.log('가격x수량의 총합 ' , maped_02); //결과 확인








        //======================================문제3================================================================
        //----------------------------------
        //  문제
        //----------------------------------
        let employees = [
            { id: 1, name: "김철수", age: 35, department: "개발", salary: 6000, years: 10 },
            { id: 2, name: "이영희", age: 28, department: "디자인", salary: 5000, years: 5 },
            { id: 3, name: "박지성", age: 40, department: "마케팅", salary: 7000, years: 15 },
            { id: 4, name: "손흥민", age: 30, department: "개발", salary: 6500, years: 7 },
            { id: 5, name: "정우성", age: 45, department: "경영", salary: 9000, years: 20 },
            { id: 6, name: "한지민", age: 29, department: "디자인", salary: 5200, years: 6 },
            { id: 7, name: "강호동", age: 50, department: "경영", salary: 8500, years: 25 },
            { id: 8, name: "유재석", age: 42, department: "마케팅", salary: 7500, years: 18 },
            { id: 9, name: "송중기", age: 32, department: "개발", salary: 6200, years: 8 },
            { id: 10, name: "수지", age: 26, department: "디자인", salary: 4800, years: 3 }
        ];

        //연봉이(salary) 6000이상이면서 근속연수(years)가 7년이상인(item.salary>=6000 && item.years>=7) 직원만 필터링해서 배열로 저장 확인
        const ex1 = employees.filter((item)=>{return item.salary>=6000 && item.years >=7})
        console.log(ex1);
        //모든 직원의 연봉(salary) 기준으로 내림차순 정렬한 배열 새로 만들기
        let ex2 = employees.sort((a,b)=>{return b.salary - a.salary})
        console.log(ex2);
        //모든 직원의 연봉(salary) 에 근속연수*100 만큼의 보너스를 추가하여 total_salary필드를 추가한 배열을 반환
        const ex3 = employees.map((item)=>{item = {...item,"total_salary":item.salary+(item.years*100)}
        return item})
        console.log(ex3);

        console.log("===========================================================================");
        //department(부서) 별로 직원들의 연봉총합을 구하세요
        // 개발/디자인/마케팅/경영
        const ex4_1 = employees.filter((item)=>{return item.department=="개발"})
                               .reduce((sum,item)=>{return sum+item.salary},0)
        console.log('개발부서 연봉 총합 ',ex4_1);
        const ex4_2 = employees.filter((item)=>{return item.department=="디자인"})
                               .reduce((sum,item)=>{return sum+item.salary},0)
        console.log('디자인부서 연봉 총합 ', ex4_2);
        const ex4_3 = employees.filter((item)=>{return item.department=="마케팅"})
                               .reduce((sum,item)=>{return sum+item.salary},0)
        console.log('마케팅부서 연봉 총합 ',ex4_3);
        const ex4_4 = employees.filter((item)=>{return item.department=="경영"})
                               .reduce((sum,item)=>{return sum+item.salary},0)
        console.log('경영부서 연봉 총합 ',ex4_4);
        // 초기값 안 주는 거 까먹으면 이상한 문자열이 붙는다
        const ex4_total = {'개발부서 연봉 총합':ex4_1,'디자인부서 연봉 총합':ex4_2,'마케팅붯 연봉 총합':ex4_3, '경영부서 연봉 총합':ex4_4}
        console.log(ex4_total);



        //--------------------문제4 풀이----------------------------------------------------------
        const result4 = employees.reduce((sum,item)=>{
            // console.log(item);
            sum[item.department]=sum[item.department] == undefined?item.salary:sum[item.department]+item.salary;
            console.log(sum);
            return sum;
        },{})
        console.log(result4);
        // 어렵다..
        //------------------------------------------------------------------------------

        
        // 연봉(salary)가 가장높은 직원을 찾아 객체하나만 반환(mdn문서에서 find를 찾아보세요 - !)

        const ex5 = employees.find((item)=>{return Math.max(item.salary)})
        console.log(ex5);

        // 뭔가 나 잘 한 거 같아서 기분 좋음






    </script>




    
</body>
</html>